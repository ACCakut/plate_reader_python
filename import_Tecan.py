## This module contains a function to import OD meaurement values from a xlsx file created by Tecan i-control.
#  Needs pandas and its optional dependency openpyxl installed.

## Info
if __name__ == "__main__":
    print(
        "This python file is meant to be included as module to other code, not to be run solely."
    )
    print(
        "If the this file is in the same folder as your code, use this code to import the function import_Teccan_xlsx:"
    )
    print(
        "from import_Tecan import *"
    )


import pandas as pd


def import_Tecan_xlsx(file_path,
                      search_term_begin = "Time [s]",
                      search_term_begin_offset = 1,
                      search_term_end = "End Time:",
                      search_term_end_offset = 4,
                      decimal_sign = ",",
                      sheet_name = "Sheet0",
                      time_unit = "s",
                      debug = False):
    """Imports xlsx files generated by Tecan i-Control software and returns a pandas dataframe containing the OD measurements.
    Since the position of the data within the Excel sheet varies, the position has to be determined by some specific strings found in the sheet.

    Args:
        file_path (str): file name (if in same folder) or path to the xlsx file that should be loaded
        
        search_term_begin (str, optional): string to search for to determine the begining of OD data. Defaults to "Time [s]".
        
        search_term_begin_offset (int, optional): How many rows are between the search term and begining of data. Defaults to 3.
        
        search_term_end (str, optional): string to search for to determine the end of OD data. Defaults to "End Time:".
        
        search_term_end_offset (int, optional): How many rows are between the search term and end of data. Defaults to 3.
        
        decimal_sign (str, optional): Decimal separator used when importing excel file. Defaults to "," (non-English style).
        
        sheet_name (str, optional): Name of the excel sheet to import. Defaults to "Sheet0".
        
        time_unit (str or int, optional): Unit to set the time index in dataframe to. Either "s", "min", "h" or an int.
                                          If int, index is stored as time_in_sheet/time_unit.  Defaults to "s".
        
        debug (bool): Whethor verbose output for debugging and troubleshooting should be printed. Default: False
        
        
        Default sheet layout (Sheet0):
                                Cycle Nr.	1	2
        search_term_begin       Time [s]	0	95,3
        1 empty row             Temp. [Â°C]	37,3	37,2
                                A1	0,256999999	0,255899996
                                A2	0,101199999	0,101099998
                                ...
                                H11	0,087899998
                                H12	0,0858
        1 empty row
        2 empty row
        3 empty row
        4 empty row
        search_term_end         End Time:	



    Returns:
        dataframe: Dataframe including all measured ODs with wells in columns and OD timeseries as rows. Index is time
    """
    
    df_raw = pd.read_excel(file_path, header=None)

    # Looking where real data begins

    # This will return a DataFrame where each cell is either True (if 'your_string' was found in that cell) or False
    mask_begin = df_raw.map(lambda x: search_term_begin in str(x))
    mask_end = df_raw.map(lambda x: search_term_end in str(x))

    # This will return a DataFrame containing only the rows where 'your_string' was found
    begin_row = df_raw[mask_begin.any(axis=1)].dropna(axis="columns") # drop all columns with empty cells

    # This will return a Series of row numbers where 'your_string' was found
    begin_row_number = mask_begin.any(axis=1)
    begin_row_number = begin_row_number[begin_row_number].index.tolist()
    if debug:
        print("Row(s) (zero-based) where search_term_begin was found, should be only one hit: ", begin_row_number)
        print(begin_row, "\n")
    end_row_number = mask_end.any(axis=1)
    end_row_number = end_row_number[end_row_number].index.tolist()
    if debug:
        print("Row(s) (zero-based) where search_term_end was found, should be exactly two hits, second one is used: ", end_row_number)
        print(df_raw[mask_end.any(axis=1)].dropna(axis="columns"), "\n")


    ## Import dataframe without bloat (drop 1st column)
    df = pd.read_excel(file_path, sheet_name="Sheet0",
                       usecols=range(1,begin_row.shape[1]),
                       skiprows=begin_row_number[0]+search_term_begin_offset+1,
                       nrows=(end_row_number[1]-begin_row_number[0]+search_term_begin_offset-search_term_end_offset-3),
                       header=None, decimal=decimal_sign) # formatting
    if debug:
        pd.set_option("display.max_rows", 6)
        pd.set_option('display.max_columns', 8)
        print("Read OD measurements (beofre transpose)\n", df, "\n")
    # Transpose data to get time in rows and wells in columns
    df = df.T

    # Set column names and indices according to excel sheet
    # Column names in sheet are stored in the first column ("A")
    columns = pd.read_excel(file_path, sheet_name="Sheet0",
                            usecols="A", # first column ("A" in Excel convention)
                            skiprows=begin_row_number[0]+search_term_begin_offset, # start
                            nrows=(end_row_number[1]-begin_row_number[0]+search_term_begin_offset-search_term_end_offset-3)).values.ravel() # number of rows to load, ravel makes simple list
    if debug: print("Extracted well names to use as column heads:\n", columns, "\n")
    df.columns = columns
    
    # Index is time in seconds or other units if chosen
    # Choose unit
    if time_unit == "s":
        time_factor = 1
    elif time_unit == "min":
        time_factor = 60
    elif time_unit == "h":
        time_factor = 3600
    elif isinstance(time_unit, int):
        time_factor = time_unit
        if debug: print("You did enter an integer as time_unit.\n")
    else:
        raise ValueError('time_unit is neither "s", "min", "h" or an integer.')
    if debug: print("Your chosen time factor to divide input time by is: ", time_factor, " since time_unit is ", str(time_unit),".\n")
       
    index = pd.read_excel(file_path, sheet_name=sheet_name, # extract Time [s] from sheet
                             usecols=range(1,begin_row.shape[1]), # second column until end
                             skiprows=begin_row_number[0], # skipping everything until row with search_term_begin (default "Time [s]").
                             nrows=1, # just 1 row in total
                             header=None, decimal=",").values.flatten() # flatten makes simple list
    if debug: print("The extracted timepoints for the index are: ", index)
    df.index = index/time_factor
    if isinstance(time_unit, int):
        df.index.name="time divided by " + str(time_unit)
    else:
        df.index.name="time in " + time_unit
    return df